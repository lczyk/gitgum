package main

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
)

const outputTemplate = `// Code generated by go generate; DO NOT EDIT.

package completions

// CompletionTemplates contains the embedded shell completion scripts
var CompletionTemplates = map[string]string{
{{- range .Templates}}
	"{{.Shell}}": ` + "`{{.Content}}`" + `,
{{- end}}
}
`

type TemplateData struct {
	Templates []Template
}

type Template struct {
	Shell   string
	Content string
}

func main() {
	if err := run(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func run() error {
	// Determine assets directory - default to relative path from repo root
	// When invoked via go:generate, working directory is the package directory
	assetsDir := "."
	if len(os.Args) > 1 {
		assetsDir = os.Args[1]
	}

	// Read all completion files
	files, err := os.ReadDir(assetsDir)
	if err != nil {
		return fmt.Errorf("failed to read assets directory: %w", err)
	}

	var templates []Template
	for _, file := range files {
		if file.IsDir() {
			continue
		}

		name := file.Name()
		// Only process .bash, .fish, .zsh files
		if !strings.HasPrefix(name, "gitgum.") {
			continue
		}

		ext := filepath.Ext(name)
		if ext != ".bash" && ext != ".fish" && ext != ".zsh" {
			continue
		}

		// Read file content
		content, err := os.ReadFile(filepath.Join(assetsDir, name))
		if err != nil {
			return fmt.Errorf("failed to read %s: %w", name, err)
		}

		// Extract shell name (remove leading dot)
		shell := strings.TrimPrefix(ext, ".")

		templates = append(templates, Template{
			Shell:   shell,
			Content: string(content),
		})
	}

	// Sort for deterministic output
	sort.Slice(templates, func(i, j int) bool {
		return templates[i].Shell < templates[j].Shell
	})

	if len(templates) == 0 {
		return fmt.Errorf("no completion templates found in %s", assetsDir)
	}

	// Generate output
	tmpl, err := template.New("output").Parse(outputTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	outputFile := filepath.Join(assetsDir, "generated.go")
	f, err := os.Create(outputFile)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer f.Close()

	data := TemplateData{Templates: templates}
	if err := tmpl.Execute(f, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	fmt.Printf("Generated %s with %d completion templates\n", outputFile, len(templates))
	return nil
}
